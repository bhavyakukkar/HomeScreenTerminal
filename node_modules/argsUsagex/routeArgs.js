import validateUsage from "validateUsage.js"
import validateArgs from "validateArgs.js"
import parseArgs from "parseArgs.js"


export default function routeArgs(argsStr, usage, author) {
    let argsObjRouted, foundMode, warn

    //let [simpUsage, usageValidation] = validateUsage(usage)
    let [usageValid, usageError] = validateUsage(usage)
    if(!usageValid)
        return [1, `Program has provided syntatically incorrect usage, please contact program author: ${author}`, usageError, null]
    
    argsStr = argsStr.trim() + " "
    let argsValidation = validateArgs(argsStr)
    if(argsValidation !== true)
        return [1, `Problem parsing provided arguments`, argsValidation, null]
    
    const argsObj = parseArgs(argsStr)
    if(usage === null)
        return argsObj
    if('modal' in usage)
        for(mode in usage.modal) {
            warn = []   //todo: clear warn before reassignment
            foundMode = false
            argsObjRouted = {mode: '', positional: {}, named: {}}  //todo: deep clean argsObjRouted before reassignment

            let mode = usage.modal[mode]
            if('positional' in mode) {
                if(argsObj.positional.length == 0)
                    continue
                let positional = mode.positional
                if('wrap' in positional)
                    argsObjRouted.positional[Object.keys(positional.keys)[0]] = argsObj.positional.join(" ")
                //then keys have to be in positional otherwise positional wouldnt be in mode
                else if(Object.keys(positional.keys).length <= argsObj.positional.length) {
                    if(Object.keys(positional.keys).length < argsObj.positional.length)
                        warn.push('Ignoring extra positional arguments supplied: ' + (Object.keys(positional.keys).slice(argsObj.positional.length).map(key => `'${key}'`).join(", ")))
                    
                    let i = 0
                    for(key in positional.keys) {
                        if(!(argsObj.positional[i].match(key.accept)))
                            break
                        argsObjRouted.positional[keys] = argsObj.positional[i]
                        i++
                    }
                    if(i != argsObj.positional.length)
                        continue
                }
                else
                    continue
            }
            if('named' in mode) {
                if(Object.keys(argsObj.named).length == 0)
                    continue
                if(Object.keys(named.keys).length > Object.keys(argsObj.named).length)
                    continue
                if(Object.keys(named.keys).length < Object.keys(argsObj.named).length);
                    //could potentially be satisfied later by optional arguments
                    //warn.push('Ignoring extra named arguments supplied: ' + (Object.keys(positional.keys).slice(argsObj.positional.length).map(key => `'${key}'`).join(", ")))
                
                let named = mode.named, broke = false
                for(key in named.keys) {
                    if(!(key in argsObj.named) || !(key.short in argsObj.named)) {
                        broke = true
                        break
                    }
                    let matchedKey = key in argsObj.named ? key : key.short
                    if(typeof(key.example) !== typeof(argsObj.named[matchedKey])) {
                        broke = true
                        break
                    }
                    argsObjRouted.named[key] = argsObj.named[argsKey]
                }
                if(broke)
                    continue
            }

            foundMode = true
            break
        }
    if('optional' in usage);

    if(warn.length > 0)
        return [2, 'Warnings that occured during parsing of arguments', warn.join('\n'), null]
}