const usageTypeStructure = [
    ['modal:u|o',[
        ['#:u|o',[
            ['positional:u|o',[
                ['wrap:b', false],
                ['keys:u|o',[
                    ['#:u|o',[
                        ['desc:s', false],
                        ['accept:r|s', false],
                        ['eg:s', false],
                    ]]
                ]]
            ]],
            ['named:u|o', [
                ['keys:u|o',[
                    ['#:u|o',[
                        ['short:n|s', false],
                        ['desc:s', false],
                        ['accept:r|s', false],
                        ['eg:s', false],
                    ]]
                ]]
            ]]
        ]]
    ]],
    ['optional:u|o',[
        ['keys:u|o',[
            ['#:u|o',[
                ['modes:s|u|o', false],
                ['short:n|s', false],
                ['desc:s', false],
                ['accept:r|s', false],
                ['eg:s', false],
            ]]
        ]]
    ]]
]

const is = (el, typeStr) => {
    for(let type of typeStr.split('|')) {
        if({
            a: () => el instanceof(Array),
            b: () => typeof(el) === 'boolean',
            c: () => typeof(el) === 'string' && el.length == 1,
            n: () => typeof(el) === 'number',
            r: () => el instanceof(RegExp),
            o: () => typeof(el) === 'object' && el !== null && !(el instanceof(Array)),
            s: () => typeof(el) === 'string',
            u: () => el === null,
        }[type]())
            return true
    }
    return false
}
const isEmpty = el => (el === null || Object.keys(el).length == 0)
const types = {a: 'array', b: 'boolean', c: 'char (string of length 1)', n: 'number', o: 'object', r: 'regexp', s: 'string', u: 'null'}

function validateUsageType(usage) {
    if(!is(usage, 'o'))
        return [false, 'usage must be of type: object or null', []]
    
    let error
    const foundModes = []

    const stitch = (parent, key, path) => {
        if(key[1] !== false) {
            if(typeof(key[0]) !== 'string') {
                for(child of key)
                    if(stitch(parent, child, path) === false)
                        return false
                return true
            }
            else {
                let [keyName, keyType] = key[0].split(':')

                if(keyName === '#') {
                    for(child of Object.keys(parent)) {
                        foundModes.push(child)
                        if(stitch(parent, [`${child}:${keyType}`, key[1]], path) === false)
                            return false
                    }
                }
                else if(keyName in parent) {
                    if(!is(parent[keyName], keyType))
                        return (error = `${path}.${keyName} must be of type: ${keyType.split('|').map(type => types[type]).join(' or ')}`) && false
                    if(isEmpty(parent[keyName]))
                        delete parent[keyName]
                    else {
                        if(stitch(parent[keyName], key[1], `${path}.${keyName}`) === false)
                            return false
                        if(isEmpty(parent[keyName]))
                            delete parent[keyName]
                    }
                }
                else
                    delete parent[keyName]
                
                return true
            }
        }
        else {
            let [keyName, keyType] = key[0].split(':')
            if(keyName in parent)
                if(!is(parent[keyName], keyType))
                    return (error = `${path}.${keyName} must be of type: ${keyType.split('|').map(type => types[type]).join(' or ')}`) && false
                else if(isEmpty(parent[keyName]))
                    delete parent[key]
            return true
        }
    }
    return [stitch(usage, usageTypeStructure, 'usage'), error, foundModes]
}

function validateUsageExtras(usage, foundModes) {
    if(isEmpty(usage))
        return [true]
    
    //error: non-unique mode or non-unique mode shorthand found
    for(let modeName of foundModes) {
        let countMode = 0, countModeShort = 0, lastShort
        for(let modeName2 of foundModes) {
            (modeName === modeName2) && (countMode++);
            ('short' in usage.modal[modeName]) && ('short' in usage.modal[modeName2]) && ((lastShort = usage.modal[modeName].short) === usage.modal[modeName2].short) && (countModeShort++)
        }
        if(countMode != 1)
            return [false, `usage mode '${modeName}' is not unique, found ${countMode - 1} other occurence(s)`]
        if(countModeShort != 1)
            return [false, `shorthand of usage mode '${modeName}', '${lastShort}' is not unique, found ${countModeShort - 1} other occurence(s)`]
    }
    
    //error: 0 modes while 1 or more optional keys contain field 'modes' with value other than null or all
    if('optional' in usage)
        for(let keyName in usage.optional.keys) {
            let key = usage.optional.keys[keyName]
            if('modes' in key && is(key.modes, 'a'))
                for(let refMode of key.modes)
                    if(!(refMode in foundModes))
                        return [false, `optional key '${keyName}' references non-existent mode '${refMode}'`]
        }
    
    //error: wrap enabled on a mode with 2 or more positional keys + free wrap if wrap:false
    for(let modeName in foundModes) {
        let mode = usage.modal[modeName], numPositionalKeys
        if('positional' in mode && ('wrap' in mode.positional) && (mode.positional.wrap === false))
            delete mode.positional.wrap
        else if('positional' in mode && ('wrap' in mode.positional) && (mode.positional.wrap === true) && ('keys' in mode) && (numPositionalKeys = Object.keys(mode.keys).length) >= 2)
            return [false, `wrap enabled on mode '${mode}' with ${numPositionalKeys} positional keys. wrap is meant to collapse all found positional arguments into a single key`]
    }
}

export default function validateUsage(usage) {
    let [valid, error, foundModes] = validateUsageType(usage)
    if(!valid)
        return [false, error]
    return validateUsageExtras(usage, foundModes)
}


/*usage = { optional: { keys: { hey: { modes: 2 } } } }
console.log(validateUsageType(usage))
console.dir(usage, {depth: null})

console.log(parseArgs(`--hey:"hey there" 1 2 3 4 `))*/